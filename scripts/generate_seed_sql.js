import XLSX from 'xlsx';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const excelPath = path.join(__dirname, '..', 'THÁI MẬU OPERATION APP_2025JAN15.xlsx');
const outputPath = path.join(__dirname, '..', 'backend', 'src', 'database', 'full_seed_2025JAN15.sql');

console.log(`Reading Excel: ${excelPath}`);
const workbook = XLSX.readFile(excelPath, { cellDates: true });

let sqlContent = `-- Auto-generated from THÁI MẬU OPERATION APP_2025JAN15.xlsx
-- Date: ${new Date().toISOString()}

`;

const TABLE_MAP = {
    'APP_MODULES': 'app_modules',
    'TENANTS': 'tenants',
    'STORE_LIST': 'store_list',
    'ROLE_MASTER': 'role_master',
    'STAFF_MASTER': 'staff_master',
    'UI_LAYOUT_CONFIG': 'ui_layout_config',
    'SUB_POSITION_MASTER': 'sub_position_master',
    'CHECKLIST_MASTER': 'checklist_master',
    'INCIDENT_MASTER': 'incident_master',
    'SHIFT_MASTER': 'shift_master',
    'MD_OBSERVED_ISSUE': 'md_observed_issue',
    'MD_COACHING_TOPIC': 'md_coaching_topic',
    'MD_NEXT_SHIFT_RISK': 'md_next_shift_risk',
    'ANNOUNCEMENTS': 'announcements'
};

// Column mappings: TableName -> { ExcelHeader: DBColumn }
const COLUMN_MAPPINGS = {
    'sub_position_master': {
        'pos_id': 'sub_id'
    }
};

// Column Type Overrides: TableName -> { DBColumn: SqlType }
const COLUMN_TYPE_OVERRIDES = {
    'shift_master': {
        'start_hour': 'TEXT',
        'end_hour': 'TEXT'
    }
};

function cleanHeader(h, tableName) {
    if (!h) return 'unknown_col';
    let cleaned = h.toString().trim().toLowerCase().replace(/[\s\-]+/g, '_');

    // Apply specific table mappings first
    if (COLUMN_MAPPINGS[tableName] && COLUMN_MAPPINGS[tableName][cleaned]) {
        return COLUMN_MAPPINGS[tableName][cleaned];
    }

    // Generic renames
    if (cleaned === 'id') return 'record_id';
    if (cleaned === 'order') return 'sort_order';
    if (cleaned === 'group') return 'group_code';
    if (cleaned === 'limit') return 'limit_val';
    if (cleaned === 'user') return 'user_info';
    if (cleaned === 'check') return 'check_val';
    if (cleaned === 'desc') return 'description';
    if (cleaned === 'date') return 'date_val';

    if (cleaned === 'brand_group') return 'brand_group_code';
    if (cleaned === 'email') return 'email';

    return cleaned;
}

function escapeSql(val) {
    if (val === null || val === undefined) return 'NULL';
    if (typeof val === 'boolean') return val ? 'TRUE' : 'FALSE';
    if (typeof val === 'number') return val;
    if (val instanceof Date) {
        if (val.getFullYear() === 1899) {
            const hours = val.getHours().toString().padStart(2, '0');
            const minutes = val.getMinutes().toString().padStart(2, '0');
            return `'${hours}:${minutes}'`;
        }
        return `'${val.toISOString()}'`;
    }
    return `'${String(val).replace(/'/g, "''")}'`;
}

function getColumnDefinition(header, sampleRow, tableName) {
    let col = cleanHeader(header, tableName);
    let type = 'TEXT';

    // Check overrides first
    if (COLUMN_TYPE_OVERRIDES[tableName] && COLUMN_TYPE_OVERRIDES[tableName][col]) {
        return { col, type: COLUMN_TYPE_OVERRIDES[tableName][col] };
    }

    const sampleVal = sampleRow ? sampleRow[header] : null;

    if (col === 'sort_order') type = 'INTEGER';
    else if (typeof sampleVal === 'boolean') type = 'BOOLEAN';
    else if (typeof sampleVal === 'number') {
        type = Number.isInteger(sampleVal) ? 'BIGINT' : 'DOUBLE PRECISION';
    }
    else if (sampleVal instanceof Date) type = 'TIMESTAMPTZ';

    if (col.endsWith('_id') || col === 'record_id' || col === 'sub_id') type = 'TEXT';
    if (col === 'active') type = 'BOOLEAN DEFAULT TRUE';

    return { col, type };
}

function generateTableSchema(tableName, sampleRow, headers) {
    let hasCreatedAt = false;
    let hasUpdatedAt = false;
    let columnDefs = [];

    headers.forEach(h => {
        const { col, type } = getColumnDefinition(h, sampleRow, tableName);

        if (col === 'created_at') hasCreatedAt = true;
        if (col === 'updated_at') hasUpdatedAt = true;

        columnDefs.push(`${col} ${type}`);
    });

    let extraColumns = [];
    if (!hasCreatedAt) {
        columnDefs.push('created_at TIMESTAMPTZ DEFAULT NOW()');
        extraColumns.push('created_at TIMESTAMPTZ DEFAULT NOW()');
    }
    if (!hasUpdatedAt) {
        columnDefs.push('updated_at TIMESTAMPTZ DEFAULT NOW()');
        extraColumns.push('updated_at TIMESTAMPTZ DEFAULT NOW()');
    }

    const createSql = `CREATE TABLE IF NOT EXISTS ${tableName} (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    ${columnDefs.join(',\n    ')}
);`;

    let alterSql = headers.map(h => {
        const { col, type } = getColumnDefinition(h, sampleRow, tableName);
        // Add IF NOT EXISTS for new columns
        let sql = `ALTER TABLE ${tableName} ADD COLUMN IF NOT EXISTS ${col} ${type};`;

        // Add explicit type cast for existing columns if there's a forceful type requirement
        if (COLUMN_TYPE_OVERRIDES[tableName] && COLUMN_TYPE_OVERRIDES[tableName][col]) {
            sql += `\nALTER TABLE ${tableName} ALTER COLUMN ${col} TYPE ${type} USING ${col}::${type};`;
        }
        return sql;
    }).join('\n');

    if (!hasCreatedAt) alterSql += `\nALTER TABLE ${tableName} ADD COLUMN IF NOT EXISTS created_at TIMESTAMPTZ DEFAULT NOW();`;
    if (!hasUpdatedAt) alterSql += `\nALTER TABLE ${tableName} ADD COLUMN IF NOT EXISTS updated_at TIMESTAMPTZ DEFAULT NOW();`;

    return { createSql, alterSql };
}

Object.keys(TABLE_MAP).forEach(sheetName => {
    const tableName = TABLE_MAP[sheetName];
    const sheet = workbook.Sheets[sheetName];
    if (!sheet) return;

    const range = XLSX.utils.decode_range(sheet['!ref']);
    const rawHeaders = [];
    for (let C = range.s.c; C <= range.e.c; ++C) {
        const cell = sheet[XLSX.utils.encode_cell({ r: 0, c: C })];
        rawHeaders.push(cell ? cell.v : `col_${C}`);
    }

    let data = XLSX.utils.sheet_to_json(sheet, { header: rawHeaders });

    // Remove header row if present
    if (data.length > 0 && String(data[0][rawHeaders[0]]) === String(rawHeaders[0])) {
        data.shift();
    }

    // FILTER EMPTY ROWS 
    data = data.filter(row => {
        const firstCol = rawHeaders[0];
        const val = row[firstCol];
        return val !== null && val !== undefined && String(val).trim() !== '';
    });

    if (data.length === 0) return;

    const { createSql, alterSql } = generateTableSchema(tableName, data[0], rawHeaders);

    sqlContent += `-- Table: ${tableName}\n`;
    sqlContent += `${createSql}\n\n`;
    sqlContent += `-- Sync Columns\n`;
    sqlContent += `${alterSql}\n\n`;

    const cleanHeaders = rawHeaders.map(h => cleanHeader(h, tableName));

    sqlContent += `INSERT INTO ${tableName} (${cleanHeaders.join(', ')}) VALUES\n`;
    const values = data.map(row => {
        const rowVals = rawHeaders.map(h => escapeSql(row[h]));
        return `(${rowVals.join(', ')})`;
    });
    sqlContent += values.join(',\n') + `\nON CONFLICT DO NOTHING;\n\n`;
});

fs.writeFileSync(outputPath, sqlContent);
console.log(`Generated SQL to: ${outputPath}`);
